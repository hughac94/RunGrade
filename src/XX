import React, { useState, useRef, useEffect } from 'react';
import maplibregl from 'maplibre-gl';
import 'maplibre-gl/dist/maplibre-gl.css';
import GPXParser from 'gpxparser';

const MAPBOX_TOKEN = 'YOUR_MAPBOX_TOKEN'; // <-- Replace with your Mapbox token

function parseGpxFile(file, callback) {
  const reader = new FileReader();
  reader.onload = (event) => {
    const gpx = new GPXParser();
    gpx.parse(event.target.result);
    const rawPoints = gpx.tracks?.[0]?.points || [];
    if (!rawPoints.length) {
      callback(null);
      return;
    }
    // Convert time strings to Date objects if possible
    const points = rawPoints.map(pt => ({
      ...pt,
      time: pt.time
        ? (typeof pt.time === 'string'
            ? new Date(pt.time)
            : pt.time instanceof Date
              ? pt.time
              : null)
        : null
    }));
    callback(points);
  };
  reader.readAsText(file);
}

export default function RacingSnakes() {
  const [gpxTracks, setGpxTracks] = useState([]); // [{name, points: [{lat, lon, ele, time}]}]
  const [sliderTime, setSliderTime] = useState(0);
  const mapContainer = useRef(null);
  const mapRef = useRef(null);

  // Handle multiple file uploads
  const handleFilesChange = (e) => {
    const files = Array.from(e.target.files);
    let loaded = 0;
    const tracks = [];
    files.forEach((file, idx) => {
      parseGpxFile(file, (points) => {
        loaded++;
        if (points) {
          tracks.push({
            name: file.name.replace(/\.gpx$/i, ''),
            points
          });
        }
        if (loaded === files.length) {
          // Sort tracks by file order
          setGpxTracks(tracks);
        }
      });
    });
  };

  // Find the global min/max time across all tracks
  const allTimes = gpxTracks.flatMap(track => track.points.map(pt => pt.time?.getTime() || 0));
  const minTime = Math.min(...allTimes);
  const maxTime = Math.max(...allTimes);

  // For each track, find the current position at sliderTime
  const currentPositions = gpxTracks.map(track => {
    if (!track.points.length) return null;
    // Find the last point <= sliderTime
    const t0 = minTime;
    const t = t0 + sliderTime * 1000;
    let pt = track.points[0];
    for (let i = 1; i < track.points.length; i++) {
      if (track.points[i].time && track.points[i].time.getTime() <= t) {
        pt = track.points[i];
      } else {
        break;
      }
    }
    return pt;
  });

  useEffect(() => {
    if (mapRef.current) return;
    mapRef.current = new maplibregl.Map({
      container: mapContainer.current,
      style: 'https://demotiles.maplibre.org/style.json',
      center: [gpxTracks[0]?.points[0]?.lon || -0.09, gpxTracks[0]?.points[0]?.lat || 51.505],
      zoom: 13,
      pitch: 60,
      bearing: 0
    });

    // Example: Add a GeoJSON source and layer for your GPX polylines here

    return () => mapRef.current && mapRef.current.remove();
  }, []);

  return (
    <div style={{ width: '100%', height: '100vh', display: 'flex', flexDirection: 'column' }}>
      <h2 style={{ textAlign: 'center' }}>üêç Racing Snakes</h2>
      <div style={{ textAlign: 'center', marginBottom: 16 }}>
        <input
          type="file"
          accept=".gpx"
          multiple
          onChange={handleFilesChange}
        />
        <div style={{ fontSize: 14, color: '#555', marginTop: 8 }}>
          Upload multiple GPX files to compare runners on a 3D map.
        </div>
      </div>
      <div ref={mapContainer} style={{ width: '100%', height: '70vh' }} />
      {gpxTracks.length > 0 && (
        <div style={{ margin: 24 }}>
          <input
            type="range"
            min={0}
            max={Math.floor((maxTime - minTime) / 1000)}
            value={sliderTime}
            onChange={e => setSliderTime(Number(e.target.value))}
            style={{ width: '100%' }}
          />
          <div style={{ textAlign: 'center' }}>
            Time: {sliderTime} seconds
          </div>
        </div>
      )}
    </div>
  );
}

// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1NmNjMjM5Zi1jZDcxLTQ1N2EtOGVmZC05MmVkMjIxNDQ4YzYiLCJpZCI6MzA4MTg5LCJpYXQiOjE3NDg4MDczNzJ9.xlytRaNjYtTFpihxq1EtqgujIEXIQWLGE-mOz2hrxkQ